这道题思维难度和代码难度都不大，就是细节处理有点麻烦，需要判断一些特殊情况（~~比如 --0.0什么的~~）。那我就直接上~~代码~~思路了。

------------
因为是一元一次方程，所以最终一定可以化成 $kx+b=0$ 的形式，整理可得 $x=-\frac{b}{k}$ ，为了~~减少变量数~~方便，将等号右边的多项式直接移到等式左边，即系数均乘 -1，可以用一个变量标记一下。

------------
## 然后就是一连串的判断：
1. 对于符号 ‘+’，‘-’，‘=’ 的处理
```cpp
if(c=='-') {b+=now*f*x;x=0;f=-1;}
if(c=='+') {b+=now*f*x;x=0;f=1;}
if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;}
```
	这里 b 为常数部分的值；now 表示相对等号的位置，左边为 1 ，右边为 -1；f 表示项的系数的正负性，x 则是项的系数。
	
    读到加号，常数累加，系数清零，符号标记为正，减号同理。读到等号则需额外将 now 改为 -1。

1. 关于数字的读入
```cpp
if(c>='0'&&c<='9') {x=x*10+c-'0';}
```
	若判定为数字则叠加当前项系数。
    
1. 关于未知数的处理
```cpp
if(c>='a'&&c<='z') {k+=now*f*x;x=0;a=c;}
```
	若判定为小写字母，则将未知数的系数累加，项系数清零，并标记未知数名 a。   

------------
至此，这一题就成功的~~解决~~挂掉了。因为(~~变量 r 的含义还没讲呢！~~)还有
## 特殊情况
1. 要是遇到 +x , -x 这种情况怎么办？

	那还不简单，系数为 0 就默认改为 1 就好了嘛。
    ```cpp
	if(c>='a'&&c<='z')
    {
    	x?k+=now*f*x:k+=now*f;
        x=0;a=c;
    }
	```
    那如果是 +0x , -0x 这种~~毒瘤~~情况又怎么办？
    
    这就需要引入一个新的变量 r 来标记是否有系数的读入。至于 r 的处理，只需要在读到数字时将 r 置为 1 ，读到其它字符都将 r 置为 0 就行了。
    ```cpp
	if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
	if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
	if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
	if(c>='a'&&c<='z')
	{
		if(r)
		{
			k+=now*f*x;x=0;
		}
		else k+=now*f;
		a=c;r=0;
	}
	if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
	```
    
1. 遇到 $-x=0$ 这种情况总是输出 -0.0 怎么办？
	
    我就是这个原因死在了第五个点，~~看了题解才知道原来是因为~~ 0 除以负数会被计算成 -0.0 。所以需要特判一下。
    
# 完整AC代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
char c,a;\/\/c用来读入,a是未知数名
int f=1,now=1,k,b,x;\/\/f初始化为正，now初始为左，k、b、x意义如上
bool r;\/\/用来判是否有数字读入
int main()
{
	while(cin>>c)\/\/各种处理上面已经解释的很清楚了……（吧）
	{
		if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
		if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
		if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
		if(c>='a'&&c<='z')
		{
			if(r)
			{
				k+=now*f*x;x=0;
			}
			else k+=now*f;
			a=c;r=0;
		}
		if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
	}
	b+=now*f*x;\/\/加上最后一项常数（若最后一项是未知数则会加0）
    double ans=double(-b*1.0\/k);
	if(ans==-0.0) ans=0;\/\/特判，将-0.0改为0
	printf("%c=%.3lf",a,ans);\/\/保留三位小数输出
	return 0;
}
```","type":"题目分析","status":2,"postTime":1549625124,"author":{"uid":109358,"name":"吴名玄","slogan":"","badge":null,"isAdmin":false,"isBanned":false,"color":"Gray","ccfLevel":0,"background":""},"thumbUp":331,"commentCount":79,"currentUserVoteType":0,"contentDescription":"这道题思维难度和代码难度都不大，就是细节处理有点麻烦，需要判断一些特殊情况（比如 --0.0什么的）。那我就直接上代码思路了。

因为是一元一次方程，所以最终一定可以化成 $kx+b=0$ 的形...","id":110042,"identifier":"ji-suan-qi-di-gai-liang","title":"计算器的改良"},{"content":"这题坑点还不少= = 被坑到废了两次宝贵的下载数据机会QwQ

第一个就是+0x和-0x这样子的（不过后来发现数据没有涉及，是我自己写的出了点偏差）；

第二个就是——也算提高了知识水平——C++里实数型如果0除以一个负数得-0 = =这操作真是爆炸！最后一个点就不善意地坑了一下，需要加一个特判

下面就是代码，为了节省宝贵的存储空间强行在线hhhhh（getchar（）大法好）

```cpp
#include<bits\/stdc++.h>
using namespace std;
typedef long long ll;\/\/以防万一用long long 
char x; ll coe,value,opp=1;\/\/coe表示系数，value表示值，opp表示在等号左边还是右边 
double ans;
int main(){
    char c=getchar();\/\/为了节省空间当然要在线 
    ll cur=0,sign=1; bool value_gotten=false;\/\/cur为当前读入的数值，sign表示当前数值符号，value_gotten是一个标记变量，字面意思是是否读入过数值，用途下面说 
    while (true){
        if (c>='a' && c<='z'){
            x=c; if (cur==0 && !value_gotten) coe+=opp*sign,value_gotten=false; \/\/这也是个坑点（虽然数据没有涉及），如果cur为0又读入了变量名称有两种情况：一时+0x或-0x，另一种是默认系数为1，value_gotten专门判断这两种情况 
            else coe+=opp*sign*cur,cur=0,sign=1,value_gotten=false;
        }
        else if (c=='-') value+=-opp*sign*cur,cur=0,sign=-1,value_gotten=false;\/\/如果是减号把当前数值加入值（如果之前是变量则当前数值为0，加入也没有影响），并清空当前数值，设value_gotten为false，符号修改为负 
        else if (c=='+') value+=-opp*sign*cur,cur=0,sign=1,value_gotten=false;\/\/加号和减号一样，只是把符号修改为正 
        else if (c>='0' && c<='9') cur=cur*10+c-'0',value_gotten=true;\/\/如果是数字，就对cur进行计算，并把value_gotten设为true 
        else if (c=='=') value+=-opp*sign*cur,cur=0,sign=1,opp=-opp,value_gotten=false;\/\/等号和加减号差不多，只是要把opp设为负 
        else {value+=-opp*sign*cur;break;}\/\/最后的值累加上去 
        c=getchar();
    }
    ans=double(value)\/coe;\/\/计算ans 
    printf("%c=%.3lf",x,ans==0?abs(ans):ans);\/\/这涉及一个很坑的地方：C++里0除以一个负数值为-0，专门避免这种情况 
    return 0;
}

```